
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tral.hmm.hmm_viterbi &#8212; TRAL 2.0.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/tral.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700|Source+Code+Pro|Armata|IM+Fell+English'
          rel='stylesheet' type='text/css' />
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head><body>
<div class="pageheader">
    <a href="http://www.isb-sib.ch/" class="sib_logo" title="SIB Swiss Institute of Bioinformatics"><img src="../../../_static/sib.png" alt="SIB" class="sib_logo" /></a>
    <a href="../../../index.html">
      <img class="headlogo" src="../../../_static/trallogo.png" alt="TRAL" />
      <span class="headlogo">Tandem Repeat Annotation Library</span>
    </a>
    <div class="headlinks">
        <a href="../../../index.html">Home</a>
        <a href="../../../install.html">Install</a>
        <a href="../../../code_docs.html">Code docs</a>
    </div>
</div>


      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tral.hmm.hmm_viterbi</h1><div class="highlight"><pre>
<span></span><span class="c1"># (C) 2012-2015 Elke Schaper</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:synopsis: Viterbi algorithm for circular hidden Markov models.</span>

<span class="sd">.. moduleauthor:: Elke Schaper &lt;elke.schaper@isb-sib.ch&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">tral</span> <span class="kn">import</span> <span class="n">configuration</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">CONFIG</span> <span class="o">=</span> <span class="n">configuration</span><span class="o">.</span><span class="n">Configuration</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">config</span>


<div class="viewcode-block" id="viterbi_with_prob"><a class="viewcode-back" href="../../../tral/hmm.html#tral.hmm.hmm_viterbi.viterbi_with_prob">[docs]</a><span class="k">def</span> <span class="nf">viterbi_with_prob</span><span class="p">(</span><span class="n">hmm</span><span class="p">,</span> <span class="n">emission</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the most probable sequence of states given a sequence of</span>
<span class="sd">    emissions and a HMM using the Viterbi algorithm, as well as the probability\</span>
<span class="sd">    of that path</span>

<span class="sd">    Get local copies of all variables.</span>
<span class="sd">    All probabilities must be given as logarithms</span>
<span class="sd">    Replace Selenocysteine (U) with Cysteine (C), replace Pyrrolysine (O) with</span>
<span class="sd">    Lysine (K) [Reason: Seldom AAs that are not part of standard amino acid</span>
<span class="sd">    substitution models.]</span>

<span class="sd">    Args:</span>
<span class="sd">        hmm (hmm): An instance of the HMM class.</span>
<span class="sd">        emission (sequence): An instance of the Sequence class.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple (path, probability)</span>
<span class="sd">        - The most likely sequence of hmm states to emit the sequence in the</span>
<span class="sd">        form of a list of str, or None if it does not meet the configured thresholds</span>
<span class="sd">        - The log10 probability of that path (-inf if path is None)</span>

<span class="sd">    Configuration:</span>
<span class="sd">        filter.basic.dict.n_effective.threshold: minimum (sequence length/hmm l_effective)</span>
<span class="sd">        hmm.l_effective_max: Max HMM size</span>
<span class="sd">        [AA|DNA].ambiguous_chars: Combine probabilities of ambiguous residues</span>

<span class="sd">    .. todo:: Adapt docstrings to refactored Viterbi -&gt; Viterbi_path classes.</span>
<span class="sd">    .. todo:: Check: Do you need local copies of all variables?</span>
<span class="sd">    .. todo:: Do the functions related to viterbi need to be summarized (e.g.</span>
<span class="sd">              in one class?) How do they relate to the Sequence class, or the</span>
<span class="sd">              HMM class?</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">emission</span><span class="p">)</span> <span class="o">/</span> <span class="n">hmm</span><span class="o">.</span><span class="n">l_effective</span> <span class="o">&lt;</span> \
            <span class="nb">float</span><span class="p">(</span><span class="n">CONFIG</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">][</span><span class="s1">&#39;basic&#39;</span><span class="p">][</span><span class="s1">&#39;dict&#39;</span><span class="p">][</span><span class="s1">&#39;n_effective&#39;</span><span class="p">][</span><span class="s1">&#39;threshold&#39;</span><span class="p">]):</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skip the HMM as it is too long (</span><span class="si">{}</span><span class="s2">) for this sequence (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                 <span class="s2">&quot;according to the filter criterion min n_effective (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hmm</span><span class="o">.</span><span class="n">l_effective</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">emission</span><span class="p">),</span>
                         <span class="n">CONFIG</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">][</span><span class="s1">&#39;basic&#39;</span><span class="p">][</span><span class="s1">&#39;dict&#39;</span><span class="p">][</span><span class="s1">&#39;n_effective&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">if</span> <span class="n">hmm</span><span class="o">.</span><span class="n">l_effective</span> <span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">CONFIG</span><span class="p">[</span><span class="s1">&#39;hmm&#39;</span><span class="p">][</span><span class="s1">&#39;l_effective_max&#39;</span><span class="p">]):</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skip the HMM as it is too long (</span><span class="si">%d</span><span class="s2">) according to the &quot;</span>
                 <span class="s2">&quot;filter criterion max hmm.l_effective (</span><span class="si">%d</span><span class="s2">).&quot;</span><span class="p">,</span> <span class="n">hmm</span><span class="o">.</span><span class="n">l_effective</span><span class="p">,</span>
                 <span class="n">CONFIG</span><span class="p">[</span><span class="s1">&#39;hmm&#39;</span><span class="p">][</span><span class="s1">&#39;l_effective_max&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="n">states</span> <span class="o">=</span> <span class="n">hmm</span><span class="o">.</span><span class="n">states</span>
    <span class="n">p_0</span> <span class="o">=</span> <span class="p">{</span><span class="n">iS</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">iS</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">hmm</span><span class="o">.</span><span class="n">p_0</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">p_e</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">iS</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">iE</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">iE</span><span class="p">,</span>
            <span class="n">value</span> <span class="ow">in</span> <span class="n">emission</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="k">for</span> <span class="n">iS</span><span class="p">,</span>
        <span class="n">emission</span> <span class="ow">in</span> <span class="n">hmm</span><span class="o">.</span><span class="n">p_e</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">p_t</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">iS</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">iT</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">iT</span><span class="p">,</span>
            <span class="n">value</span> <span class="ow">in</span> <span class="n">transition</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="k">for</span> <span class="n">iS</span><span class="p">,</span>
        <span class="n">transition</span> <span class="ow">in</span> <span class="n">hmm</span><span class="o">.</span><span class="n">p_t</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="n">iE</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">CONFIG</span><span class="p">[</span><span class="n">hmm</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">][</span><span class="s1">&#39;all_chars&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">iE</span> <span class="ow">in</span> <span class="n">emission</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;There is an unknown amino acid in:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">emission</span><span class="p">))</span>

    <span class="c1"># In case there are ambiguous characters in the sequence, calculate the</span>
    <span class="c1"># expected frequencies of the char (AA or DNA) that they could stand for</span>
    <span class="c1"># from the emission frequencies of the hmm in the neutral state &quot;N&quot;.</span>
    <span class="n">d_ambiguous_local</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># ambiguous char -&gt; concrete char -&gt; log10 prob</span>
    <span class="k">for</span> <span class="n">iA</span> <span class="ow">in</span> <span class="n">CONFIG</span><span class="p">[</span><span class="n">hmm</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">][</span><span class="s1">&#39;ambiguous_chars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">d_ambiguous_local</span><span class="p">[</span><span class="n">iA</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">iA</span> <span class="ow">in</span> <span class="n">emission</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">p_e</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">i_ambiguous</span><span class="p">]</span>
                                 <span class="k">for</span> <span class="n">i_ambiguous</span> <span class="ow">in</span> <span class="n">CONFIG</span><span class="p">[</span><span class="n">hmm</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">][</span><span class="s1">&#39;ambiguous_chars&#39;</span><span class="p">][</span><span class="n">iA</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i_ambiguous</span> <span class="ow">in</span> <span class="n">CONFIG</span><span class="p">[</span><span class="n">hmm</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">][</span><span class="s1">&#39;ambiguous_chars&#39;</span><span class="p">][</span><span class="n">iA</span><span class="p">]:</span>
                <span class="n">d_ambiguous_local</span><span class="p">[</span><span class="n">iA</span><span class="p">][</span><span class="n">i_ambiguous</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_e</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">][</span><span class="n">i_ambiguous</span><span class="p">]</span> <span class="o">-</span> <span class="n">total</span>

    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;p_0: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_0</span><span class="p">))</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;p_e: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_e</span><span class="p">))</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;p_t: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_t</span><span class="p">))</span>

    <span class="c1"># Initialisation of the probabilities on the first emitted character</span>
    <span class="k">if</span> <span class="n">emission</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">d_ambiguous_local</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">{</span><span class="n">iS</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="n">p_0</span><span class="p">[</span><span class="n">iS</span><span class="p">],</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">iS</span><span class="p">]}</span> <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">states</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="c1"># Calculate the average emission probability of ambiguity chars.</span>
            <span class="c1"># The numerical trick to calculate the average log values in high</span>
            <span class="c1"># precision is reused in the next for-loop and described there.</span>
            <span class="n">l_p_emission</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">d_ambiguous_local</span><span class="p">[</span>
                    <span class="n">emission</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i_ambiguous</span><span class="p">]</span> <span class="o">+</span>
                <span class="n">p_e</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="n">i_ambiguous</span><span class="p">]</span> <span class="k">for</span> <span class="n">i_ambiguous</span> <span class="ow">in</span> <span class="n">d_ambiguous_local</span><span class="p">[</span>
                    <span class="n">emission</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="n">max_p</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">l_p_emission</span><span class="p">)</span>
            <span class="n">path</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="s1">&#39;probability&#39;</span><span class="p">]</span> <span class="o">+=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">max_p</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l_p_emission</span><span class="p">]))</span> <span class="o">+</span> <span class="n">max_p</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">{</span><span class="n">iS</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="n">p_0</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_e</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="n">emission</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                     <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">iS</span><span class="p">]}</span> <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">states</span><span class="p">}</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Path: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

    <span class="c1"># Viterbi on all remaining emitted characters</span>
    <span class="k">for</span> <span class="n">iE</span> <span class="ow">in</span> <span class="n">emission</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Emitted: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iE</span><span class="p">))</span>

        <span class="c1"># Determine next most probable state and its probability ...</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i_former</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iE</span> <span class="ow">in</span> <span class="n">d_ambiguous_local</span><span class="p">:</span>
                    <span class="c1"># Calculate the probability of being in state iS and</span>
                    <span class="c1"># emitting i_ambiguous for any of the AAs that the</span>
                    <span class="c1"># ambiguous iE stands for.</span>
                    <span class="c1"># Then, average over these probabilities (taking into</span>
                    <span class="c1"># account the background frequencies of all i_ambiguous)</span>
                    <span class="n">d_p_former</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">i_ambiguous</span><span class="p">:</span> <span class="n">probability_of_the_former_state</span><span class="p">(</span>
                            <span class="n">i_former</span><span class="p">,</span>
                            <span class="n">iS</span><span class="p">,</span>
                            <span class="n">i_ambiguous</span><span class="p">,</span>
                            <span class="n">p_e</span><span class="p">,</span>
                            <span class="n">p_t</span><span class="p">,</span>
                            <span class="n">path</span><span class="p">,</span>
                        <span class="p">)</span> <span class="k">for</span> <span class="n">i_ambiguous</span> <span class="ow">in</span> <span class="n">d_ambiguous_local</span><span class="p">[</span><span class="n">iE</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
                    <span class="n">d_p_former</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">i_ambiguous</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i_ambiguous</span><span class="p">,</span>
                        <span class="n">j</span> <span class="ow">in</span> <span class="n">d_p_former</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">j</span><span class="p">}</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_p_former</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Next, we need to calculated a weighted average over</span>
                        <span class="c1"># log10 probabilities.</span>
                        <span class="c1"># For this purpose, we need to transform the log10ps</span>
                        <span class="c1"># back to ps.</span>
                        <span class="c1"># However, the ps might have too small values.</span>
                        <span class="c1"># We apply a numerical trick:</span>
                        <span class="c1"># Instead of</span>
                        <span class="c1"># sum(w(i)p(i)) = sum(10 ** (log(w(i)) + log(p(i))))</span>
                        <span class="c1"># we calculate</span>
                        <span class="c1"># sum(w(i)p(i)) = sum(10 ** (log(w(i)) + log(p(i)) + k )) / (10 ** k),</span>
                        <span class="c1"># which can easily be shown to be equivalent.</span>
                        <span class="c1"># For (-k), we choose the maximum value in log(w(i)) +</span>
                        <span class="c1"># log(p(i)), as it corresponds to the maximum and thus</span>
                        <span class="c1"># most pronounced probability of the sum.</span>
                        <span class="n">l_p_former</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">i</span> <span class="o">+</span>
                            <span class="n">d_ambiguous_local</span><span class="p">[</span><span class="n">iE</span><span class="p">][</span><span class="n">i_ambiguous</span><span class="p">]</span> <span class="k">for</span> <span class="n">i_ambiguous</span><span class="p">,</span>
                            <span class="n">i</span> <span class="ow">in</span> <span class="n">d_p_former</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
                        <span class="n">max_p</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">l_p_former</span><span class="p">)</span>
                        <span class="n">p</span><span class="p">[</span><span class="n">i_former</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span>
                            <span class="nb">sum</span><span class="p">([</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">max_p</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l_p_former</span><span class="p">]))</span> <span class="o">+</span> <span class="n">max_p</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">p_former</span> <span class="o">=</span> <span class="n">probability_of_the_former_state</span><span class="p">(</span>
                        <span class="n">i_former</span><span class="p">,</span>
                        <span class="n">iS</span><span class="p">,</span>
                        <span class="n">iE</span><span class="p">,</span>
                        <span class="n">p_e</span><span class="p">,</span>
                        <span class="n">p_t</span><span class="p">,</span>
                        <span class="n">path</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">p_former</span><span class="p">:</span>
                        <span class="n">p</span><span class="p">[</span><span class="n">i_former</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_former</span>

            <span class="c1"># This error will occur when it is not possible to enter a state iS</span>
            <span class="c1"># at emission iE. This can happen for more complex HMMs, but should</span>
            <span class="c1"># not happen for the simple</span>
            <span class="c1"># circular HMMs that we consider here. It means that state iS</span>
            <span class="c1"># cannot be reached by emission iE. Either iS cannot emit iE, or iS</span>
            <span class="c1"># cannot be reached by transitions at this point.</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="p">{}:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;The dict p is empty. This should never happen.&quot;</span><span class="p">)</span>
            <span class="c1"># Detect the most likely path.</span>
            <span class="n">next_state</span><span class="p">,</span> <span class="n">p_next_state</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">p</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">path</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="s1">&#39;probability_next&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_next_state</span>
            <span class="n">path</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="s1">&#39;path_next&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">next_state</span><span class="p">][</span><span class="s1">&#39;path&#39;</span><span class="p">][:]</span>
            <span class="n">path</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="s1">&#39;path_next&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>

        <span class="c1"># ... and update the path accordingly</span>
        <span class="k">for</span> <span class="n">iV</span> <span class="ow">in</span> <span class="n">path</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">iV</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iV</span><span class="p">[</span><span class="s1">&#39;path_next&#39;</span><span class="p">][:]</span>
            <span class="n">iV</span><span class="p">[</span><span class="s1">&#39;probability&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iV</span><span class="p">[</span><span class="s1">&#39;probability_next&#39;</span><span class="p">]</span>
        <span class="c1"># LOG.debug(&quot;Path: {0}&quot;.format(path))</span>

    <span class="c1"># Which overall path is the most likely?</span>
    <span class="n">path_summary</span> <span class="o">=</span> <span class="p">{</span><span class="n">iS</span><span class="p">:</span> <span class="n">path</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="s1">&#39;probability&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">states</span><span class="p">}</span>
    <span class="n">most_likely_terminal_state</span><span class="p">,</span> <span class="n">p_most_likely_path</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
        <span class="n">path_summary</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">most_likely_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">most_likely_terminal_state</span><span class="p">][</span><span class="s1">&#39;path&#39;</span><span class="p">]</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;The most likely path is </span><span class="si">%s</span><span class="s2">. It has a score of </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">,</span>
              <span class="nb">str</span><span class="p">(</span><span class="n">most_likely_path</span><span class="p">),</span> <span class="n">p_most_likely_path</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">most_likely_path</span><span class="p">,</span> <span class="n">p_most_likely_path</span></div>


<div class="viewcode-block" id="logodds"><a class="viewcode-back" href="../../../tral/hmm.html#tral.hmm.hmm_viterbi.logodds">[docs]</a><span class="k">def</span> <span class="nf">logodds</span><span class="p">(</span><span class="n">hmm</span><span class="p">,</span> <span class="n">emission</span><span class="p">,</span> <span class="n">logprob</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the log-odds score of the given emission</span>

<span class="sd">    Log odds is defined as:</span>

<span class="sd">        LO = log10 Pr[viterbi probability]/Pr[null]</span>

<span class="sd">    where the null model is given by a constant background frequency f(x) for each amino acid:</span>

<span class="sd">        Pr[null] = sum(f(x) for x in emission)</span>

<span class="sd">    Args:</span>
<span class="sd">        - hmm (HMM): hmm used to calculate logprob</span>
<span class="sd">        - emission (str): emitted residues</span>
<span class="sd">        - logprob (float): log10 of the match probability, as returned by viterby_with_prob</span>

<span class="sd">    Returns:</span>
<span class="sd">        (float) LO</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># background freq dist</span>
    <span class="n">background</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">hmm</span><span class="o">.</span><span class="n">p_e</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">])</span>

    <span class="c1"># total null probability</span>
    <span class="n">null</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">emission</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">background</span><span class="p">:</span>
            <span class="c1"># perhaps this residue is ambiguous</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">CONFIG</span><span class="p">[</span><span class="n">hmm</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">][</span><span class="s1">&#39;ambiguous_chars&#39;</span><span class="p">]:</span>
                <span class="c1"># For ambiguous characters in the sequence, calculate the</span>
                <span class="c1"># expected frequencies of the char (AA or DNA) that they could stand for</span>
                <span class="c1"># from the emission frequencies of the hmm in the neutral state &quot;N&quot;.</span>
                <span class="c1"># e.g. Pr[B] = (Pr[D]^2 + Pr[N]^2)/(Pr[D] + Pr[N])</span>

                <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">squares</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">concrete</span> <span class="ow">in</span> <span class="n">CONFIG</span><span class="p">[</span><span class="n">hmm</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">][</span><span class="s1">&#39;ambiguous_chars&#39;</span><span class="p">][</span><span class="n">e</span><span class="p">]:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">background</span><span class="p">[</span><span class="n">concrete</span><span class="p">]</span>
                    <span class="n">total</span> <span class="o">+=</span> <span class="n">p</span>
                    <span class="n">squares</span> <span class="o">+=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span>
                <span class="n">background</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">squares</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>

        <span class="c1"># may throw KeyError if still unrecognized</span>
        <span class="n">null</span> <span class="o">+=</span> <span class="n">background</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">logprob</span> <span class="o">-</span> <span class="n">null</span></div>


<div class="viewcode-block" id="viterbi"><a class="viewcode-back" href="../../../tral/hmm.html#tral.hmm.hmm_viterbi.viterbi">[docs]</a><span class="k">def</span> <span class="nf">viterbi</span><span class="p">(</span><span class="n">hmm</span><span class="p">,</span> <span class="n">emission</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the most probable sequence of states given a sequence of</span>
<span class="sd">    emissions and a HMM using the Viterbi algorithm</span>

<span class="sd">    Get local copies of all variables.</span>
<span class="sd">    All probabilities must be given as logarithms</span>
<span class="sd">    Replace Selenocysteine (U) with Cysteine (C), replace Pyrrolysine (O) with</span>
<span class="sd">    Lysine (K) [Reason: Seldom AAs that are not part of standard amino acid</span>
<span class="sd">    substitution models.]</span>

<span class="sd">    Args:</span>
<span class="sd">        hmm (hmm): An instance of the HMM class.</span>
<span class="sd">        emission (sequence): An instance of the Sequence class.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The most likely sequence of hmm states to emit the sequence in the</span>
<span class="sd">        form of a list of str, or None if it does not meet the configured thresholds</span>

<span class="sd">    Configuration:</span>
<span class="sd">        filter.basic.dict.n_effective.threshold: minimum (sequence length/hmm l_effective)</span>
<span class="sd">        hmm.l_effective_max: Max HMM size</span>
<span class="sd">        [AA|DNA].ambiguous_chars: Combine probabilities of ambiguous residues</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">viterbi_with_prob</span><span class="p">(</span><span class="n">hmm</span><span class="p">,</span> <span class="n">emission</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">path</span></div>


<div class="viewcode-block" id="probability_of_the_former_state"><a class="viewcode-back" href="../../../tral/hmm.html#tral.hmm.hmm_viterbi.probability_of_the_former_state">[docs]</a><span class="k">def</span> <span class="nf">probability_of_the_former_state</span><span class="p">(</span><span class="n">i_former</span><span class="p">,</span> <span class="n">iS</span><span class="p">,</span> <span class="n">iE</span><span class="p">,</span> <span class="n">p_e</span><span class="p">,</span> <span class="n">p_t</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the probability of i_former, given iS and iE together with</span>
<span class="sd">    the dicts of emission and transition probabilities.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Exclude paths with a zero probability (i.e. a log(probability) set to</span>
    <span class="c1"># None)</span>
    <span class="k">if</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">p_t</span><span class="p">[</span><span class="n">i_former</span><span class="p">]</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">p_t</span><span class="p">[</span><span class="n">i_former</span><span class="p">][</span><span class="n">iS</span><span class="p">]</span> <span class="ow">and</span> <span class="n">iE</span> <span class="ow">in</span> <span class="n">p_e</span><span class="p">[</span>
            <span class="n">iS</span><span class="p">]</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">p_e</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="n">iE</span><span class="p">]</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">path</span><span class="p">[</span><span class="n">i_former</span><span class="p">][</span><span class="s1">&#39;probability&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">path</span><span class="p">[</span><span class="n">i_former</span><span class="p">][</span><span class="s1">&#39;probability&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_t</span><span class="p">[</span><span class="n">i_former</span><span class="p">][</span><span class="n">iS</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_e</span><span class="p">[</span><span class="n">iS</span><span class="p">][</span><span class="n">iE</span><span class="p">]</span>

    <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="distance_index"><a class="viewcode-back" href="../../../tral/hmm.html#tral.hmm.hmm_viterbi.distance_index">[docs]</a><span class="k">def</span> <span class="nf">distance_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function to calculate the distance between two indices in a</span>
<span class="sd">    circular HMM.</span>

<span class="sd">    Args:</span>
<span class="sd">        i (int): first index</span>
<span class="sd">        j (int): second index</span>
<span class="sd">        length (int): length of the HMM</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The distance between the indices ``i`` and ``j``: As the HMM</span>
<span class="sd">        is circular ``j`` may have a smaller value than ``i``, even though</span>
<span class="sd">        ``j`` is ahead of ``i``.</span>

<span class="sd">    .. todo:: May be replaced by a simple mod, as distance_index is used only</span>
<span class="sd">        once in the code at current.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">length</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span></div>


<div class="viewcode-block" id="hmm_path_to_maximal_complete_tandem_repeat_units"><a class="viewcode-back" href="../../../tral/hmm.html#tral.hmm.hmm_viterbi.hmm_path_to_maximal_complete_tandem_repeat_units">[docs]</a><span class="k">def</span> <span class="nf">hmm_path_to_maximal_complete_tandem_repeat_units</span><span class="p">(</span>
        <span class="n">sequences</span><span class="p">,</span>
        <span class="n">paths</span><span class="p">,</span>
        <span class="n">l_effective</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert several viterbi paths of a hmm on several sequences into the</span>
<span class="sd">    corresponding hmm units.</span>

<span class="sd">    Be ungreedy: Start from the last index in the cluster of all start state</span>
<span class="sd">    and end state indices.</span>

<span class="sd">    Only integrate repeat units that are at least alpha complete (be it before</span>
<span class="sd">    of after)</span>
<span class="sd">    If you prefer absolute number of characters to filter which repeat units</span>
<span class="sd">    are used, and which not, change this in two occurrences of alpha.</span>

<span class="sd">    Assume that all states are counted starting on 1.</span>

<span class="sd">    Args:</span>
<span class="sd">        sequences (list of str): A list of sequences.</span>
<span class="sd">        paths (list of list of str): A list of Viterbi paths</span>
<span class="sd">        l_effective (int): length of the HMM used to create the Viterbi paths.</span>
<span class="sd">        alpha (Float): alpha element [0,1].</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list of multiple sequence alignments (MSAs) in the form of a list of</span>
<span class="sd">        list of str, e.g. ``[[&#39;ATAILC&#39;, &#39;ATAILC&#39;, &#39;ACALKG&#39;], ...]``.</span>

<span class="sd">    Raises:</span>
<span class="sd">        Exception: If alpha is not in [0,1].</span>

<span class="sd">    .. todo:: Use sequence instances instead of just strings for `sequences`?</span>
<span class="sd">    .. todo:: Check example for returns.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">alpha</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.6</span>

    <span class="c1"># Find the first match state index used by all paths (add None if None)</span>
    <span class="n">l_terminal_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">l_repeat_present</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">iP</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">iP</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">):</span>
                <span class="n">l_terminal_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">iP</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                <span class="n">l_repeat_present</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_repeat_present</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">iP</span> <span class="ow">in</span> <span class="n">path</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">iP</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">):</span>
                <span class="n">l_terminal_indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">iP</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="o">%</span> <span class="n">l_effective</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">break</span>

    <span class="c1"># Find the max distance between two indices</span>
    <span class="n">l_used_indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">l_terminal_indices</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_used_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_used_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">start_index</span> <span class="o">=</span> <span class="n">l_used_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span>
                     <span class="nb">zip</span><span class="p">(</span><span class="n">l_used_indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">l_used_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span> <span class="o">+</span> \
                    <span class="p">[</span><span class="n">l_effective</span> <span class="o">-</span> <span class="n">l_used_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">l_used_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">max_distance_index</span><span class="p">,</span> <span class="n">max_distance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">distances</span><span class="p">),</span>
                                               <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Define the start_index</span>
        <span class="n">start_index</span> <span class="o">=</span> <span class="n">l_used_indices</span><span class="p">[</span>
            <span class="p">(</span><span class="n">max_distance_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">l_used_indices</span><span class="p">)]</span>

    <span class="c1"># Get all TR units according to shift.</span>
    <span class="n">lMSA</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">ib_present</span><span class="p">,</span> <span class="n">i_seq</span><span class="p">,</span> <span class="n">i_path</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">l_repeat_present</span><span class="p">,</span> <span class="n">sequences</span><span class="p">,</span> <span class="n">paths</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ib_present</span><span class="p">:</span>
            <span class="n">lMSA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">msa</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Intialise the last used index and the first msa_unit</span>
        <span class="n">current_index</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">msa_unit</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">iS</span><span class="p">,</span> <span class="n">iP</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">i_seq</span><span class="p">,</span> <span class="n">i_path</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">iP</span> <span class="o">==</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">iP</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">match_state_index</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">iP</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="p">(</span><span class="n">l_effective</span> <span class="o">-</span> <span class="n">start_index</span><span class="p">))</span> <span class="o">%</span> <span class="n">l_effective</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">match_state_index</span> <span class="o">&gt;=</span> <span class="n">current_index</span><span class="p">:</span>
                <span class="c1"># We are staying within the same repeat unit.</span>
                <span class="n">msa_unit</span> <span class="o">+=</span> <span class="n">iS</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We are starting a new repeat unit.</span>
                <span class="n">msa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msa_unit</span><span class="p">)</span>
                <span class="n">msa_unit</span> <span class="o">=</span> <span class="n">iS</span>
            <span class="n">current_index</span> <span class="o">=</span> <span class="n">match_state_index</span>

        <span class="n">msa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msa_unit</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">msa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">l_effective</span><span class="p">:</span>
                <span class="n">msa</span> <span class="o">=</span> <span class="n">msa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">msa</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">l_effective</span><span class="p">:</span>
                <span class="n">msa</span> <span class="o">=</span> <span class="n">msa</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">lMSA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">lMSA</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

    <span class="k">return</span> <span class="n">lMSA</span></div>


<div class="viewcode-block" id="hmm_path_to_non_aligned_tandem_repeat_units"><a class="viewcode-back" href="../../../tral/hmm.html#tral.hmm.hmm_viterbi.hmm_path_to_non_aligned_tandem_repeat_units">[docs]</a><span class="k">def</span> <span class="nf">hmm_path_to_non_aligned_tandem_repeat_units</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">l_effective</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a viterbi &lt;path&gt; of a hmm of length &lt;l_effective&gt; on &lt;sequence&gt;</span>
<span class="sd">    into the corresponding tandem repeat</span>

<span class="sd">    Extract the tandem repeat alignment from a sequence given a Viterbi path.</span>
<span class="sd">    Ignore the alignment information in the Viterbi path. For example, all</span>
<span class="sd">    emissions labelled with M1 (match state 1) align according to the HMM.</span>
<span class="sd">    However, this method does not use this information. Therefore, for example</span>
<span class="sd">    the first characters in the repeat units do not necessarily align, and the</span>
<span class="sd">    repeat units are not necessarily of same length.</span>

<span class="sd">    Assume that all states are counted starting on 1.</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence (str): A sequence as a string.</span>
<span class="sd">        paths (list of list of str): A list of Viterbi paths</span>
<span class="sd">        l_effective (int): length of the HMM used to create the Viterbi paths.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A multiple sequence alignment (MSA) created from the most likely path</span>
<span class="sd">        along the hmm in the form of a list of str.</span>

<span class="sd">    .. todo:: Use sequence instance instead of string for input?</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">begin</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>
    <span class="c1"># If no repeat was found, return None.</span>
    <span class="k">if</span> <span class="n">begin</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="ow">or</span> <span class="n">path</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">splitter</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\d+)&quot;</span><span class="p">)</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">((</span><span class="n">splitter</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">iP</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">splitter</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">iP</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))),</span> <span class="n">iS</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iS</span><span class="p">,</span> <span class="n">iP</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="n">begin</span><span class="p">:],</span> <span class="n">path</span><span class="p">[</span><span class="n">begin</span><span class="p">:])</span> <span class="k">if</span> <span class="n">iP</span> <span class="o">!=</span> <span class="s1">&#39;C&#39;</span><span class="p">]</span>

    <span class="n">shift</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">index_shift</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Empty&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">l_effective</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">shift</span><span class="p">)</span> <span class="o">%</span>
                               <span class="n">l_effective</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l_effective</span><span class="p">)]</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;The tandem repeat is shifted by: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

    <span class="n">repeat_msa</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">repeat_unit</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">last_used_index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">l_effective</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">iM</span><span class="p">,</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">iM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span>
                <span class="n">repeat_unit</span> <span class="o">+=</span> <span class="n">iS</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">repeat_msa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">repeat_unit</span><span class="p">)</span>
                <span class="n">repeat_unit</span> <span class="o">=</span> <span class="n">iS</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">iM</span><span class="p">,</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">last_used_index</span><span class="p">:</span>
                <span class="n">repeat_unit</span> <span class="o">+=</span> <span class="n">iS</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">repeat_msa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">repeat_unit</span><span class="p">)</span>
                <span class="n">repeat_unit</span> <span class="o">=</span> <span class="n">iS</span>
            <span class="n">last_used_index</span> <span class="o">=</span> <span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="n">repeat_msa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">repeat_unit</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">repeat_msa</span></div>


<div class="viewcode-block" id="hmm_path_to_aligned_tandem_repeat_units"><a class="viewcode-back" href="../../../tral/hmm.html#tral.hmm.hmm_viterbi.hmm_path_to_aligned_tandem_repeat_units">[docs]</a><span class="k">def</span> <span class="nf">hmm_path_to_aligned_tandem_repeat_units</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">most_likely_path</span><span class="p">,</span> <span class="n">l_effective</span><span class="p">,</span>
                                            <span class="n">translate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    WARNING: Currently do not rely on this function!!</span>
<span class="sd">    The output seems to have missing characters and too much gaps.</span>
<span class="sd">    The function needs review in order to be used.</span>
<span class="sd">    todo: fix hidden bug!</span>

<span class="sd">    Convert a viterbi path in an hmm of length ``l_effective`` on the</span>
<span class="sd">     sequence into a corresponding tandem repeat.</span>

<span class="sd">    Extract the tandem repeat alignment from a sequence given a Viterbi path.</span>
<span class="sd">    Use alignment information in the Viterbi path. For example, all emissions</span>
<span class="sd">    labelled with M1 (match state 1) align according to the HMM. Insert gaps</span>
<span class="sd">    for insertions and deletions accordingly.</span>
<span class="sd">    Thus, for example the first characters in the repeat units do necessarily</span>
<span class="sd">    align, albeit some of them may be gaps. Also, all repeat units are</span>
<span class="sd">    necessarily of same length.</span>

<span class="sd">    Assume that all states are counted starting on 0, unless the ``translate``</span>
<span class="sd">    flag is set.</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence (str): A sequence as a string.</span>
<span class="sd">        most_likely_path (list of str): a Viterbi path.</span>
<span class="sd">        l_effective (int): length of the HMM used to create the Viterbi paths.</span>
<span class="sd">        translate (bool): This function assumes that HMM states are enumerated</span>
<span class="sd">            starting on 0.</span>
<span class="sd">            If the HMM states are enumerated starting on 1, set this flag for</span>
<span class="sd">            transformation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The function returns a tuple consisting of 3 values.</span>
<span class="sd">        The tuple contains:</span>

<span class="sd">        * ``msa``: A repeat instance.</span>
<span class="sd">        * ``begin``: The start index of the repeat on the sequence.</span>
<span class="sd">        * ``shift``: The index of the HMM where the cut between repeat units is set.</span>


<span class="sd">    .. warning:: [None].</span>
<span class="sd">    .. todo:: Use sequence instance instead of just a string?</span>
<span class="sd">    .. todo:: Check: How is the returned `begin` defined? Starting counting on 0 or 1?</span>
<span class="sd">        Is it the index of the last flanking character, or the first repeat character?</span>
<span class="sd">    .. todo:: Can we update this function, e.g. to not assume that HMM states start on 0?</span>
<span class="sd">    .. todo:: Check the docstring, reformat returns.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">begin</span> <span class="o">=</span> <span class="n">most_likely_path</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>
    <span class="c1"># If no repeat was found, return None.</span>
    <span class="k">if</span> <span class="n">begin</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="ow">or</span> <span class="n">most_likely_path</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">translate</span><span class="p">:</span>
        <span class="c1"># In the input data, the states are counted starting on 1. Subtract 1.</span>
        <span class="n">most_likely_path</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">most_likely_path</span><span class="p">]</span>

    <span class="n">splitter</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\d+)&quot;</span><span class="p">)</span>

    <span class="n">mapping</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">((</span><span class="n">splitter</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">iP</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">splitter</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">iP</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))),</span> <span class="n">iS</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iS</span><span class="p">,</span> <span class="n">iP</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="n">begin</span><span class="p">:],</span> <span class="n">most_likely_path</span><span class="p">[</span><span class="n">begin</span><span class="p">:])</span>
        <span class="k">if</span> <span class="n">iP</span> <span class="o">!=</span> <span class="s1">&#39;C&#39;</span><span class="p">]</span>

    <span class="n">shift</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">index_shift</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">l_effective</span> <span class="o">-</span> <span class="n">shift</span><span class="p">)</span> <span class="o">%</span> <span class="n">l_effective</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l_effective</span><span class="p">)]</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;The tandem repeat is shifted by: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

    <span class="n">insertions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">repeat_text</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">insertions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>
    <span class="n">max_used_index_M</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_used_index_I</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">last_used_index</span> <span class="o">=</span> <span class="n">shift</span>

    <span class="k">for</span> <span class="n">iM</span><span class="p">,</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Iteration iS: </span><span class="si">%d</span><span class="s2">, iM: </span><span class="si">%d</span><span class="s2">, last_used_index: </span><span class="si">%d</span><span class="s2">, &quot;</span>
                  <span class="s2">&quot;max_used_index_M: </span><span class="si">%d</span><span class="s2">, max_used_index_I: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="n">iS</span><span class="p">,</span> <span class="n">iM</span><span class="p">,</span> <span class="n">last_used_index</span><span class="p">,</span> <span class="n">max_used_index_M</span><span class="p">,</span> <span class="n">max_used_index_I</span><span class="p">)</span>

        <span class="c1"># If we have entered a new repeat unit, add a new element to &lt;insertions&gt;</span>
        <span class="c1"># (Including some index magic, e.g. the insertion state index is shifted by one (lowered))</span>
        <span class="k">if</span> <span class="n">iM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">max_used_index_M</span> <span class="ow">or</span>
                             <span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">max_used_index_I</span><span class="p">):</span>
            <span class="n">insertions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>
            <span class="n">max_used_index_M</span> <span class="o">=</span> <span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">max_used_index_I</span> <span class="o">=</span> <span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="n">iM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;I&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_used_index_I</span> <span class="ow">or</span>
                               <span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_used_index_M</span><span class="p">):</span>
            <span class="n">insertions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>
            <span class="n">max_used_index_I</span> <span class="o">=</span> <span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">max_used_index_M</span> <span class="o">=</span> <span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">iM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
            <span class="n">max_used_index_M</span> <span class="o">=</span> <span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_used_index_I</span> <span class="o">=</span> <span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Save match state and deletion information</span>
        <span class="k">if</span> <span class="n">iM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
            <span class="n">n_deletions</span> <span class="o">=</span> <span class="n">distance_index</span><span class="p">(</span><span class="n">last_used_index</span><span class="p">,</span> <span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l_effective</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">repeat_text</span> <span class="o">+=</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="n">n_deletions</span> <span class="o">+</span> <span class="n">iS</span>
            <span class="n">last_used_index</span> <span class="o">=</span> <span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">insertions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">index_shift</span><span class="p">[</span><span class="n">iM</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">+=</span> <span class="n">iS</span>

    <span class="n">msa</span> <span class="o">=</span> <span class="p">[</span><span class="n">repeat_text</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">l_effective</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">repeat_text</span><span class="p">),</span> <span class="n">l_effective</span><span class="p">)]</span>
    <span class="n">msa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">l_effective</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">msa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">msaT</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">msa</span><span class="p">)]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;This tandem repeat has </span><span class="si">%d</span><span class="s2"> repeat units.&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;These insertions were detected: </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">insertions</span><span class="p">))</span>

    <span class="n">msa_temp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># For each site ...</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l_effective</span><span class="p">):</span>
        <span class="n">msa_temp</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">msaT</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># ... for each tandem repeat unit, check whether there are insertions.</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">insertions</span><span class="p">):</span>
            <span class="c1"># Backtranslate the index used in insertions (shift by one to the</span>
            <span class="c1"># right (increase))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">l_effective</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">l_effective</span><span class="p">]:</span>
                    <span class="n">msa_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="n">iS</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">msa</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">msa_temp</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">msa</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">shift</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>


  </body>
</html>