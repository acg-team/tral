
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tral.repeat.repeat_pvalue &#8212; TRAL 2.0.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/tral.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700|Source+Code+Pro|Armata|IM+Fell+English'
          rel='stylesheet' type='text/css' />
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head><body>
<div class="pageheader">
    <a href="http://www.isb-sib.ch/" class="sib_logo" title="SIB Swiss Institute of Bioinformatics"><img src="../../../_static/sib.png" alt="SIB" class="sib_logo" /></a>
    <a href="../../../index.html">
      <img class="headlogo" src="../../../_static/trallogo.png" alt="TRAL" />
      <span class="headlogo">Tandem Repeat Annotation Library</span>
    </a>
    <div class="headlinks">
        <a href="../../../index.html">Home</a>
        <a href="../../../install.html">Install</a>
        <a href="../../../code_docs.html">Code docs</a>
    </div>
</div>


      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tral.repeat.repeat_pvalue</h1><div class="highlight"><pre>
<span></span><span class="c1"># (C) 2015 Elke Schaper</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :synopsis: The repeat pvalue module.</span>

<span class="sd">    .. moduleauthor:: Elke Schaper &lt;elke.schaper@isb-sib.ch&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">bisect</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>

<span class="kn">from</span> <span class="nn">tral.paths</span> <span class="kn">import</span> <span class="n">config_file</span><span class="p">,</span> <span class="n">CONFIG_DIR</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># ######################### REPEAT SCORE P-VALUE CALCULATION FUNCTIONS ########</span>
<span class="c1"># #################### phylo &amp; entropy ########################################</span>


<div class="viewcode-block" id="empirical_list"><a class="viewcode-back" href="../../../tral/repeat.html#tral.repeat.repeat_pvalue.empirical_list">[docs]</a><span class="k">def</span> <span class="nf">empirical_list</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sequence_type</span><span class="o">=</span><span class="s1">&#39;AA&#39;</span><span class="p">,</span> <span class="n">score_type</span><span class="o">=</span><span class="s1">&#39;phylo&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load and return a numpy list with 10,000 empirical values of the user defined</span>
<span class="sd">        distribution from an external file.</span>


<span class="sd">    If no distribution is available for a given ``l`` and ``n``, the closest values for</span>
<span class="sd">    ``l`` and ``n`` are chosen instead.</span>

<span class="sd">    For the standard model score &quot;phylo&quot;, currently values are available until</span>

<span class="sd">        * ``l_max`` = 99</span>
<span class="sd">        * ``n_max`` = 49</span>
<span class="sd">        * ``total_repeat_length_max`` = 1000</span>

<span class="sd">    For ``l`` &lt;=  ``l_max`` and ``n`` &lt;=  ``n_max`` and ``n*l`` &lt;=  ``total_repeat_length_max``</span>
<span class="sd">    all values are available.</span>

<span class="sd">    For other values, we use the closest distribution, assuming that values change little</span>
<span class="sd">    (heuristic assumption!).</span>

<span class="sd">    Args:</span>
<span class="sd">        l (int): The length of the repeat unit.</span>
<span class="sd">        n (int): The number of repeat units.</span>
<span class="sd">        sequence_type (str): The type of the sequence: either &quot;AA&quot; or &quot;DNA&quot;.</span>
<span class="sd">        score_type: The model of repeat evolution used. E.g. &quot;phylo&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A numpy list of length 10.000</span>


<span class="sd">    .. todo:: Define &quot;phylo&quot; model.</span>
<span class="sd">    .. todo:: Perhaps add distributions beyond l_max, n_max.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">l_max</span> <span class="o">=</span> <span class="mi">99</span>
    <span class="n">n_max</span> <span class="o">=</span> <span class="mi">49</span>
    <span class="k">if</span> <span class="n">score_type</span> <span class="o">==</span> <span class="s1">&#39;entropy&#39;</span><span class="p">:</span>
        <span class="n">l_max</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="n">n_max</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">total_repeat_length_max</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l_max</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_max</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">*</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">total_repeat_length_max</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;l: </span><span class="si">%d</span><span class="s2"> and n: </span><span class="si">%d</span><span class="s2"> are bigger than the total_repeat_length_max: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">total_repeat_length_max</span><span class="p">))</span>
        <span class="c1"># Dirty little hack: as we do not have data for this pair of l and n,</span>
        <span class="c1"># apply nearest data file.</span>
        <span class="k">while</span> <span class="n">l</span> <span class="o">*</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">total_repeat_length_max</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">config_file</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;pvalue&quot;</span><span class="p">,</span>
                           <span class="n">sequence_type</span><span class="p">,</span>
                           <span class="n">score_type</span><span class="p">,</span>
                           <span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.npz&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">CONFIG_DIR</span><span class="p">,</span>
                                <span class="s2">&quot;data&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;pvalue&quot;</span><span class="p">,</span>
                                <span class="n">sequence_type</span><span class="p">,</span>
                                <span class="n">score_type</span><span class="p">,</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.npz&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Complete pdf file </span><span class="si">%s</span><span class="s2"> to calculate the pvalue does not exist!&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>

    <span class="n">empirical_list_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="c1"># It is necessary to close the numpy filehandle.</span>
    <span class="c1"># Otherwise, there will be too many open operating system filehandles</span>
    <span class="c1"># if you run this function many times (more than ulimit -n allows, that is)</span>
    <span class="n">empirical_list_part</span> <span class="o">=</span> <span class="n">empirical_list_all</span><span class="p">[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">]</span>
    <span class="n">empirical_list_all</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">empirical_list_part</span></div>


<div class="viewcode-block" id="pvalue_from_empirical_list"><a class="viewcode-back" href="../../../tral/repeat.html#tral.repeat.repeat_pvalue.pvalue_from_empirical_list">[docs]</a><span class="k">def</span> <span class="nf">pvalue_from_empirical_list</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="p">,</span> <span class="n">score_type</span><span class="o">=</span><span class="s1">&#39;phylo&#39;</span><span class="p">,</span> <span class="n">score_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">empirical</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the p-Value of a score_type for the given `tandemrepeat`.</span>


<span class="sd">    The p-Value is the number of scores for comparable tandem repeats, i.e. of</span>
<span class="sd">    same repeat unit length and repeat unit copy number that are as good or</span>
<span class="sd">    better.</span>

<span class="sd">    Args:</span>
<span class="sd">        tandemrepeat (Repeat): An instance of the Repeat class.</span>
<span class="sd">        score_type: The model of repeat evolution used. E.g. &quot;phylo&quot;.</span>
<span class="sd">        score_value (float): The value of the score of the Repeat instance.</span>
<span class="sd">        empirical: The null distribution of the score for repeats of the same</span>
<span class="sd">                    type.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pvalue: A float.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">score_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">score_value</span> <span class="o">=</span> <span class="n">tandemrepeat</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">score_type</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">empirical</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">empirical</span> <span class="o">=</span> <span class="n">empirical_list</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="o">.</span><span class="n">l_effective</span><span class="p">,</span> <span class="n">tandemrepeat</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
                                   <span class="n">tandemrepeat</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">,</span> <span class="n">score_type</span><span class="p">)</span>

    <span class="c1"># A smaller score is a better score for all scores in this list.</span>
    <span class="k">if</span> <span class="n">score_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;entropy&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">score_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="n">empirical</span><span class="p">,</span> <span class="n">score_value</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">empirical</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">empirical</span><span class="p">,</span> <span class="n">score_value</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">empirical</span><span class="p">)</span></div>


<span class="c1"># ####################### pSim &amp; parsimony: read in PDF #######################</span>

<div class="viewcode-block" id="column_pdf"><a class="viewcode-back" href="../../../tral/repeat.html#tral.repeat.repeat_pvalue.column_pdf">[docs]</a><span class="k">def</span> <span class="nf">column_pdf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">score_type</span><span class="o">=</span><span class="s1">&#39;psim&#39;</span><span class="p">,</span> <span class="n">sequence_type</span><span class="o">=</span><span class="s1">&#39;AA&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load and return the probability density function of the score on random</span>
<span class="sd">        ``sequence_type`` data of length ``n``.</span>

<span class="sd">    Load and return the probability density function of the score on random</span>
<span class="sd">    ``sequence_type`` data of length ``n``.</span>
<span class="sd">    This method handels scores with distributions independent of ``l``. This includes</span>
<span class="sd">    all parsimony scores, and excludes model based scores.</span>

<span class="sd">    The order of the values in the probability density function is WORST FIRST: The first</span>
<span class="sd">    values describe the probability for &quot;bad&quot; scores, the last values the probabilities</span>
<span class="sd">    for &quot;top&quot; scores.</span>

<span class="sd">    Currently, for all models values are available until</span>

<span class="sd">        * ``n_max`` = 150</span>

<span class="sd">    For ``n`` &lt;=  ``n_max`` all values are available. If no distribution is available for</span>
<span class="sd">    a given ``n`` the closest values for ``n`` is used.</span>

<span class="sd">    For values of ``n`` above ``n_max``, the ``n_max`` pdf is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int): The number of repeat units.</span>
<span class="sd">        score_type: The heuristic model used. E.g. &quot;psim&quot;.</span>
<span class="sd">        sequence_type (str): The type of the sequence: either &quot;AA&quot; or &quot;DNA&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A numpy list of length 10.000</span>

<span class="sd">    .. todo:: Check return type.</span>
<span class="sd">    .. todo:: Check how this method concurs with the ``empirical_list`` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Currently, the pdfs are only save up to n_max = 150</span>
    <span class="n">n_max</span> <span class="o">=</span> <span class="mi">150</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">config_file</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;pvalue&quot;</span><span class="p">,</span> <span class="n">sequence_type</span><span class="p">,</span> <span class="n">score_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_max</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;.txt&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pdf_file</span><span class="p">:</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">pdf_file</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="s1">&#39;excel-tab&#39;</span><span class="p">)]</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pdf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span></div>

<span class="c1"># ############################# pSim &amp; parsimony ##############################</span>


<div class="viewcode-block" id="calculate_repeat_structure"><a class="viewcode-back" href="../../../tral/repeat.html#tral.repeat.repeat_pvalue.calculate_repeat_structure">[docs]</a><span class="k">def</span> <span class="nf">calculate_repeat_structure</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate the number of columns with a certain number of gaps for each column in</span>
<span class="sd">    a ``Repeat`` instance.</span>

<span class="sd">    You can use a different null distribution for each column of different length for both</span>
<span class="sd">    the parsimony and the pSim score. Therefore, calculate the structure of the TR before</span>
<span class="sd">    you calculate the null distribution of tandem repeat scores of tandem repeats with</span>
<span class="sd">    the same gap distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int): The number of repeat units.</span>
<span class="sd">        score: The heuristic model used. E.g. &quot;psim&quot;.</span>
<span class="sd">        sequence_type (str): The type of the sequence: either &quot;AA&quot; or &quot;DNA&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        l_repeat_structure (list)</span>
<span class="sd">        n_repeat_structure (int)</span>

<span class="sd">    .. todo:: Include exact definition of returned values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">repeat_structure</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">tandemrepeat</span><span class="o">.</span><span class="n">msaTD</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">column</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">))</span>
    <span class="p">]</span>
    <span class="n">n_repeat_structure</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">repeat_structure</span><span class="p">))</span>
    <span class="n">l_repeat_structure</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">repeat_structure</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n_repeat_structure</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">l_repeat_structure</span><span class="p">,</span> <span class="n">n_repeat_structure</span></div>


<span class="c1"># #################### DERIVE p-Value distributions ###########################</span>

<div class="viewcode-block" id="calc_pvalues"><a class="viewcode-back" href="../../../tral/repeat.html#tral.repeat.repeat_pvalue.calc_pvalues">[docs]</a><span class="k">def</span> <span class="nf">calc_pvalues</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="n">result_file_path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span>
                 <span class="n">scoretypes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;phylo&#39;</span><span class="p">,</span> <span class="s1">&#39;phylo_gap&#39;</span><span class="p">],</span> <span class="n">gappy_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create and save a null distribution for ``repeats`` scores for p-Value calculation.</span>

<span class="sd">    You can use a different null distribution for each column of different length for both</span>
<span class="sd">    the parsimony and the pSim score. Therefore, calculate the structure of the TR before</span>
<span class="sd">    you calculate the null distribution of tandem repeat scores of tandem repeats with</span>
<span class="sd">    the same gap distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        repeats (list of Repeat): A list of ``Repeat`` instances.</span>
<span class="sd">        result_file_path (str): Path to result folder.</span>
<span class="sd">        file_name (str): Name of result file.</span>
<span class="sd">        scoretypes (list of str):  List of scores. E.g. [&#39;phylo&#39;,&#39;phylo_gap&#39;].</span>
<span class="sd">        gappy_data (bool): True if any of ``repeats`` contain gaps, else False.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># If the repeats are not gappy, than you can use always the same distribution of scores</span>
    <span class="c1"># on random data to calculate the p-Value. Otherwise, there might be deletion columns</span>
    <span class="c1"># and the distribution should be loaded each time</span>
    <span class="c1"># &#39;pvalue_from_empirical_list&#39; is called.</span>
    <span class="n">empirical_list_local</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i_score_type</span> <span class="ow">in</span> <span class="n">scoretypes</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;parsimony&#39;</span> <span class="o">==</span> <span class="n">i_score_type</span><span class="p">:</span>
            <span class="n">test_statistic</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">pvalue_pars</span><span class="p">(</span><span class="n">i_repeat</span><span class="p">)</span> <span class="k">if</span> <span class="n">i_repeat</span><span class="o">.</span><span class="n">l_effective</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i_repeat</span> <span class="ow">in</span> <span class="n">repeats</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s1">&#39;pSim&#39;</span> <span class="o">==</span> <span class="n">i_score_type</span><span class="p">:</span>
            <span class="n">test_statistic</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">pvalue_psim</span><span class="p">(</span><span class="n">i_repeat</span><span class="p">)</span> <span class="k">if</span> <span class="n">i_repeat</span><span class="o">.</span><span class="n">l_effective</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i_repeat</span> <span class="ow">in</span> <span class="n">repeats</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">gappy_data</span><span class="p">:</span>
                <span class="n">empirical_list_local</span> <span class="o">=</span> <span class="n">empirical_list</span><span class="p">(</span>
                    <span class="n">repeats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">l_effective</span><span class="p">,</span>
                    <span class="n">repeats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
                    <span class="n">repeats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">,</span>
                    <span class="n">i_score_type</span><span class="p">)</span>
            <span class="n">test_statistic</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">pvalue_from_empirical_list</span><span class="p">(</span><span class="n">i_repeat</span><span class="p">,</span> <span class="n">i_score_type</span><span class="p">,</span>
                                            <span class="n">empirical</span><span class="o">=</span><span class="n">empirical_list_local</span><span class="p">)</span>
                 <span class="k">if</span> <span class="n">i_repeat</span><span class="o">.</span><span class="n">l_effective</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i_repeat</span> <span class="ow">in</span> <span class="n">repeats</span><span class="p">]</span>
        <span class="n">score_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result_file_path</span><span class="p">,</span> <span class="n">i_score_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">score_path</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">score_path</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">score_path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">score_path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">test_statistic</span><span class="p">))</span></div>


<div class="viewcode-block" id="d_average_multinom"><a class="viewcode-back" href="../../../tral/repeat.html#tral.repeat.repeat_pvalue.d_average_multinom">[docs]</a><span class="k">def</span> <span class="nf">d_average_multinom</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sequence_type</span><span class="p">,</span> <span class="n">score_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Helper function for the analytic calculation of parsimony or pSim scores.</span>

<span class="sd">    Called by ``d_average_multiple_max_multinom`` or ``d_average_multiple_pars_multinom``.</span>

<span class="sd">    Return the ``l``-times self-convoluted pdf of the score on random sequence_type data</span>
<span class="sd">    of length ``n``. The order of the pdf is kept from ``column_pdf()``.</span>

<span class="sd">    For details see:</span>

<span class="sd">    Schaper, E., Kajava, A., Hauser, A., &amp; Anisimova, M. Repeat or not repeat?</span>
<span class="sd">    --Statistical validation of tandem repeat prediction in genomic sequences.</span>
<span class="sd">    Nucleic Acids Research (2012).</span>

<span class="sd">    Args:</span>
<span class="sd">        l (int): The length of the repeat unit.</span>
<span class="sd">        n (int): The number of repeat units.</span>
<span class="sd">        sequence_type (str): The type of the sequence: either &quot;AA&quot; or &quot;DNA&quot;.</span>
<span class="sd">        score_type: The model of repeat evolution used. Either &#39;psim&#39; or &#39;parsimony&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (description missing)</span>

<span class="sd">    .. warning:: if precision higher than max(uint32) use uint64 instead.</span>
<span class="sd">            CHECK: http://docs.scipy.org/doc/numpy/user/basics.types.html</span>

<span class="sd">    .. todo:: Describe return value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">complete_pdf</span> <span class="o">=</span> <span class="n">column_pdf</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">score_type</span><span class="o">=</span><span class="n">score_type</span><span class="p">,</span> <span class="n">sequence_type</span><span class="o">=</span><span class="n">sequence_type</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">single_column_pdf</span> <span class="o">=</span> <span class="n">complete_pdf</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">complete_pdf</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">complete_pdf</span><span class="p">,</span> <span class="n">single_column_pdf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">complete_pdf</span></div>

<span class="c1"># ####################### pSim ################################################</span>


<span class="c1"># python 2: precision must be float</span>
<div class="viewcode-block" id="d_average_multiple_max_multinom"><a class="viewcode-back" href="../../../tral/repeat.html#tral.repeat.repeat_pvalue.d_average_multiple_max_multinom">[docs]</a><span class="k">def</span> <span class="nf">d_average_multiple_max_multinom</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">10000.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate null distribution for e.g. the pSim score for repeats of type ``tandemrepeat``</span>
<span class="sd">        as a probability density function.</span>

<span class="sd">    Analytically calculate the p-Value distribution for the pSim score for repeats of</span>
<span class="sd">    type ``tandemrepeat``. The derivation is described in:</span>

<span class="sd">    Schaper, E., Kajava, A., Hauser, A., &amp; Anisimova, M. Repeat or not repeat?</span>
<span class="sd">    --Statistical validation of tandem repeat prediction in genomic sequences.</span>
<span class="sd">    Nucleic Acids Research (2012).</span>

<span class="sd">    Args:</span>
<span class="sd">        tandemrepeat (Repeat): A ``Repeat`` instance.</span>
<span class="sd">        precision (float): The precision of the returned probability density function in</span>
<span class="sd">        terms of the length of the resulting list.</span>

<span class="sd">    Returns:</span>
<span class="sd">        p (list of float): cumulated probabilities from 0 to 1.</span>
<span class="sd">        unnamed (list of float): scores corresponding to the probabilities in ``p``.</span>

<span class="sd">    .. warning:: if precision higher than max(uint32) use uint64 instead.</span>
<span class="sd">            CHECK: http://docs.scipy.org/doc/numpy/user/basics.types.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">l_repeat_structure</span><span class="p">,</span> <span class="n">n_repeat_structure</span> <span class="o">=</span> <span class="n">calculate_repeat_structure</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">d_average_multinom</span><span class="p">(</span><span class="n">l_repeat_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_repeat_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="n">tandemrepeat</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">,</span> <span class="n">score_type</span><span class="o">=</span><span class="s1">&#39;psim&#39;</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">l_repeat_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]:(</span><span class="n">l_repeat_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_repeat_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)]</span> <span class="o">*</span>
                    <span class="p">(</span><span class="n">precision</span> <span class="o">/</span> <span class="n">n_repeat_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint32&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_repeat_structure</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># return best values first. for pSim, best = 1, worst = 0</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">val</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">l_repeat_structure</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_repeat_structure</span><span class="p">)):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">d_average_multinom</span><span class="p">(</span><span class="n">l_repeat_structure</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                               <span class="n">n_repeat_structure</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                               <span class="n">tandemrepeat</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">,</span>
                                               <span class="n">score_type</span><span class="o">=</span><span class="s1">&#39;psim&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span>
                   <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">l_repeat_structure</span><span class="p">[</span><span class="n">i</span><span class="p">]:(</span><span class="n">l_repeat_structure</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_repeat_structure</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)]</span> <span class="o">*</span>
                 <span class="p">(</span><span class="n">precision</span> <span class="o">/</span> <span class="n">n_repeat_structure</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                 <span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint32&#39;</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
        <span class="c1"># return best values first. for pSim, best = 1, worst = 0</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">l_repeat_structure</span><span class="p">)))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="pvalue_psim"><a class="viewcode-back" href="../../../tral/repeat.html#tral.repeat.repeat_pvalue.pvalue_psim">[docs]</a><span class="k">def</span> <span class="nf">pvalue_psim</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate the p-Value of the pSim score for a Repeat.</span>

<span class="sd">    Retrieve the probability density function for repeats of the same type as ``tandemrepeat``.</span>
<span class="sd">    Then, calculate the p-Value given this probability density function, and the</span>
<span class="sd">    pSim score of ``tandemrepeat``.</span>

<span class="sd">    Args:</span>
<span class="sd">        tandemrepeat (Repeat): A ``Repeat`` instance.</span>

<span class="sd">    Returns:</span>
<span class="sd">        p-Value (float)</span>

<span class="sd">    .. todo:: Check the method&#39;s behaviour if ``tandemrepeat`` s parsimony score has not been</span>
<span class="sd">        calculated before.</span>
<span class="sd">    .. todo:: Check exception: if pdf == False: return 1.</span>
<span class="sd">    .. todo:: Describe ``precision``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">precision</span> <span class="o">=</span> <span class="mf">10000.</span>

    <span class="n">pdf</span> <span class="o">=</span> <span class="n">d_average_multiple_max_multinom</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
    <span class="n">cumsum_pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1">#index = np.where(tandemrepeat.score(&#39;pSim&#39;) == pdf[1])[0]</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="s1">&#39;pSim&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">pdf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">precision</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># standard case: score is included in pdf[0]</span>
        <span class="k">return</span><span class="p">(</span><span class="n">cumsum_pdf</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="s1">&#39;pSim&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pdf</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># if pars is not exactly included in list, give back mean of value above</span>
        <span class="c1"># and value below (should only occur due to numerical imprecision)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span><span class="p">((</span><span class="n">cumsum_pdf</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">cumsum_pdf</span><span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># This should only occur if score(&#39;pSim&#39;) is really bad or really good</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span></div>

<span class="c1"># ################## parsimony ################################################</span>


<span class="c1"># python 2: precision must be float</span>
<div class="viewcode-block" id="d_average_multiple_pars_multinom"><a class="viewcode-back" href="../../../tral/repeat.html#tral.repeat.repeat_pvalue.d_average_multiple_pars_multinom">[docs]</a><span class="k">def</span> <span class="nf">d_average_multiple_pars_multinom</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">10000.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate null distribution for the parsimony score for repeats of type ``tandemrepeat``</span>
<span class="sd">        as a probability density function.</span>

<span class="sd">    Analytically calculate the p-Value distribution for the parsimony score for repeats of</span>
<span class="sd">    type ``tandemrepeat``. The derivation is described in:</span>

<span class="sd">    Schaper, E., Kajava, A., Hauser, A., &amp; Anisimova, M. Repeat or not repeat?</span>
<span class="sd">    --Statistical validation of tandem repeat prediction in genomic sequences.</span>
<span class="sd">    Nucleic Acids Research (2012).</span>

<span class="sd">    Args:</span>
<span class="sd">        tandemrepeat (Repeat): A ``Repeat`` instance.</span>
<span class="sd">        precision (float): The precision of the returned probability density function in</span>
<span class="sd">        terms of the length of the resulting list.</span>

<span class="sd">    Returns:</span>
<span class="sd">        p (list of float): cumulated probabilities from 0 to 1.</span>
<span class="sd">        unnamed (list of float): scores corresponding to the probabilities in ``p``.</span>

<span class="sd">    .. warning:: if precision higher than max(uint32) use uint64 instead.</span>
<span class="sd">            CHECK: http://docs.scipy.org/doc/numpy/user/basics.types.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">l_repeat_structure</span><span class="p">,</span> <span class="n">n_repeat_structure</span> <span class="o">=</span> <span class="n">calculate_repeat_structure</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">d_average_multinom</span><span class="p">(</span>
        <span class="n">l_repeat_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_repeat_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">tandemrepeat</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">,</span> <span class="n">score_type</span><span class="o">=</span><span class="s1">&#39;parsimony&#39;</span>
    <span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[(</span><span class="n">l_repeat_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_repeat_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mf">1.</span><span class="p">]</span> <span class="o">*</span>
         <span class="p">(</span><span class="n">precision</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_repeat_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">))</span>
         <span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint32&#39;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_repeat_structure</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># return best values first. for parsimony, best = 0, worst = 1</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">l_repeat_structure</span><span class="p">)))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_repeat_structure</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p</span><span class="p">,</span>
                             <span class="n">d_average_multinom</span><span class="p">(</span>
                                 <span class="n">l_repeat_structure</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                 <span class="n">n_repeat_structure</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                 <span class="n">tandemrepeat</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">,</span> <span class="n">score_type</span><span class="o">=</span><span class="s1">&#39;parsimony&#39;</span><span class="p">)</span>
                             <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

                <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[(</span><span class="n">l_repeat_structure</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_repeat_structure</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mf">1.</span><span class="p">]</span> <span class="o">*</span>
                     <span class="p">(</span><span class="n">precision</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_repeat_structure</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">))</span>
                     <span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint32&#39;</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Failed on: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">l_repeat_structure</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">n_repeat_structure</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># return best values first. for parsimony, best = 0, worst = 1.</span>
        <span class="c1"># Here, the  np.bincount() and np.unique() funs did the reordering.</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">l_repeat_structure</span><span class="p">))</span></div>


<div class="viewcode-block" id="pvalue_pars"><a class="viewcode-back" href="../../../tral/repeat.html#tral.repeat.repeat_pvalue.pvalue_pars">[docs]</a><span class="k">def</span> <span class="nf">pvalue_pars</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate the p-Value of the parsimony score for a Repeat.</span>

<span class="sd">    Retrieve the probability density function for repeats of the same type as</span>
<span class="sd">    ``tandemrepeat``. Then, calculate the p-Value given this probability</span>
<span class="sd">    density function, and the parsimony score of ``tandemrepeat``.</span>

<span class="sd">    Args:</span>
<span class="sd">        tandemrepeat (Repeat): A ``Repeat`` instance.</span>

<span class="sd">    Returns:</span>
<span class="sd">        p-Value (float)</span>

<span class="sd">    .. todo:: Check the method&#39;s behaviour if ``tandemrepeat`` s parsimony</span>
<span class="sd">              score has not been calculated before.</span>
<span class="sd">    .. todo:: Check exception: if pdf == False: return 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">precision</span> <span class="o">=</span> <span class="mf">10000.</span>

    <span class="n">pdf</span> <span class="o">=</span> <span class="n">d_average_multiple_pars_multinom</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
    <span class="c1"># Check the following three lines:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pdf</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">cumsum_pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1">#index = np.where(pdf[1] == tandemrepeat.score(&#39;parsimony&#39;))[0]</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">tandemrepeat</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="s1">&#39;parsimony&#39;</span><span class="p">)</span> <span class="o">-</span>
            <span class="n">pdf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mf">1.</span> <span class="o">/</span>
        <span class="n">precision</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># standard case: score is included in pdf[0]</span>
        <span class="k">return</span> <span class="n">cumsum_pdf</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="s1">&#39;parsimony&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">pdf</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># if pars is not exactly included in list, give back mean of value</span>
        <span class="c1"># above and value below (should only occur due to numerical</span>
        <span class="c1"># imprecision)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">cumsum_pdf</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">cumsum_pdf</span><span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># This should only occur if score(&#39;parsimony&#39;) is really bad</span>
        <span class="k">return</span> <span class="mi">1</span></div>


<span class="c1"># #################### gap penalty ############################################</span>

<div class="viewcode-block" id="gap_penalty"><a class="viewcode-back" href="../../../tral/repeat.html#tral.repeat.repeat_pvalue.gap_penalty">[docs]</a><span class="k">def</span> <span class="nf">gap_penalty</span><span class="p">(</span><span class="n">tandemrepeat</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate the gap penalty for a ``Repeat`` given mutation rate ``mu``.</span>

<span class="sd">    Args:</span>
<span class="sd">        tandemrepeat (Repeat): A ``Repeat`` instance.</span>
<span class="sd">        mu (float): The mutation rate.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Gap penalty (float)</span>

<span class="sd">    .. todo:: Define ``mu`` more precisely.</span>
<span class="sd">    .. todo:: Is this function called from anywhere? In case, consider refactoring.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">((</span><span class="n">mu</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mu</span><span class="p">))</span> <span class="o">**</span> <span class="n">tandemrepeat</span><span class="o">.</span><span class="n">n_gap_structure</span><span class="p">)</span> <span class="o">*</span> <span class="n">tandemrepeat</span><span class="o">.</span><span class="n">p_gap_structure</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>


  </body>
</html>